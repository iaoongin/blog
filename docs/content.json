{"pages":[],"posts":[{"title":"各种开发工具国内加速配置","text":"简介​各种开发工具配置国内加速 git设置代理 12345678910111213#设置全局socks5代理git config --global http.proxy socks5://127.0.0.1:10808# 设置全局http代理git config --global http.proxy http://127.0.0.1:10809# 取消当前代理git config --unset http.proxy#取消全局代理git config --global --unset http.proxy 查看代理 1git config --global http.proxy maven123456789&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt; go设置 1go env -w GOPROXY=https://goproxy.cn,direct 查看 1go env containerd查看当前配置信息 123456789101112131415yum install -y jqcrictl info | jq .config.registry{ \"mirrors\": { \"docker.io\": { \"endpoint\": [ \"https://docker.mirrors.ustc.edu.cn\" ], \"rewrite\": null } }, \"configs\": null, \"auths\": null, \"headers\": null 修改 123456cp /var/lib/rancher/k3s/agent/etc/containerd/config.toml /var/lib/rancher/k3s/agent/etc/containerd/config.toml.tmpl# 在 config.toml.tmpl 文件中添加[plugins.cri.registry.mirrors] [plugins.cri.registry.mirrors.\"docker.io\"] endpoint = [\"https://docker.mirrors.ustc.edu.cn\"] 重启 1systemctl restart k3s docker修改 /etc/docker/daemon.json 12345{&quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]} 重启服务 1systemctl restart docker yarn查看 1yarn config get registry 设置成淘宝镜像 123456789yarn config set registry http://registry.npm.taobao.org/yarn config set disturl https://npm.taobao.org/dist -gyarn config set electron_mirror https://npm.taobao.org/mirrors/electron/ -gyarn config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/ -gyarn config set phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs/ -gyarn config set chromedriver_cdnurl https://cdn.npm.taobao.org/dist/chromedriver -gyarn config set operadriver_cdnurl https://cdn.npm.taobao.org/dist/operadriver -gyarn config set fse_binary_host_mirror https://npm.taobao.org/mirrors/fsevents -g npm查看 1npm get registry 设置成淘宝镜像 123456789npm config set registry http://registry.npm.taobao.org/npm install phantomjs --phantomjs_cdnurl=http://npm.taobao.org/mirrors/phantomjsnpm install chromedriver --chromedriver_cdnurl=http://npm.taobao.org/mirrors/chromedrivernpm install operadriver --operadriver_cdnurl=http://npm.taobao.org/mirrors/operadrivernpm config set disturl https://npm.taobao.org/distnpm config set electron_mirror https://npm.taobao.org/mirrors/electron/npm config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/npm config set phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs/ ubuntu备份之前的sources.list文件 1sudo cp -ra /etc/apt/sources.list /etc/apt/sources.list.bak 修改sources.list文件 1sudo vim /etc/apt/sources.list ubuntu 18.04 lts (bionic) 12345678910deb http://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse ubuntu 20.04 lts (focal) 123456789101112131415deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse 更新apt缓存 12sudo apt updatesudo apt upgrade","link":"/2021/12/17/各种开发工具国内加速配置/"},{"title":"原神私服 - 客户端连接教程","text":"最后更新于：2022-12-02， 支持3.2 本文带来的客户端连接服务器的方式。 准备 原神服务器 ( 自建参考教程, 服务器购买) ip: 119.29.13.11 106.52.60.67 端口: 444 官方客户端 国际版/国服版都可 PC 端打补丁下载补丁 国服：https://wwdy.lanzouf.com/ieJBy0hiv14h 国际服：https://wwdy.lanzouf.com/iRQHs0hiv35a 替换文件 注意 UserAssembly.dll 可以考虑备份一下，便于恢复官方服务 将对应的补丁覆盖到以下文件即可。 国服: YuanShen_Data\\Native\\UserAssembly.dll 国际服: GenshinImpact_Data\\Native\\UserAssembly.dll PC 端配置代理 （推荐方式二）方式一: GrassClipper-X下载解压下载地址 https://github.com/Grasscutters/GrassClipper-X/releases/download/1.0.0/GrassClipper-X-1.0.0-win-x64.7z 注意解压路径不能包含中文，否则会导致代理脚本无法执行。 启动 配置注：需勾选 自定义服务。 注：此处游戏路径为 GenshinImpact.exe 而非启动器路径。 启动游戏 输入账号密码注：此处服务器是开放注册，随机账户密码就可登录。 进入游戏 方式二 米哈游代理 (推荐)下载地址https://wwc.lanzouv.com/iU8eO0dlo8kh 解压直接启动 更改为服务器对应地址，开启代理 参考项目GrasscutterCommandGenerator 指令生成器： https://github.com/jie65535/GrasscutterCommandGeneratorGrassClipper-X 原神代理启动器：https://github.com/Grasscutters/GrassClipper-X","link":"/2022/05/20/原神私服搭建 - 客户端连接/"},{"title":"原神私服 - 使用 docker-compose 搭建服务端","text":"原神除草机来了 (ಥ_ಥ) ，让你体验抽卡模拟器，拥有全满命角色。 准备 服务器 环境: docker, docker-compose ip: 119.29.13.11 开放端口: 444, 22102 服务器购买【腾讯云】多款云产品1折起，买云服务器送免费机器，最长免费续3个月 配置创建文件 /opt/grasscutter/docker-compose.yaml123456789101112131415161718192021222324252627282930version: '3'services: mongodb: restart: unless-stopped image: mongo ports: - \"6969:27017\" volumes: - ./data_db:/data/db environment: MONGO_INITDB_ROOT_USERNAME: yff MONGO_INITDB_ROOT_PASSWORD: yffjglcms grasscutter: restart: unless-stopped container_name: dockergc image: siakbary/dockergc:debian-dev-4.5 # -b 修改对对应的ip command: -d 'mongodb://yff:yffjglcms@mongodb:27017' -b '119.29.13.11' -v '0.0.0.0' # -f 'yes' volumes: - ./resources:/home/Grasscutter/resources #- ./proxy_config.py:/home/Grasscutter/proxy_config.py - ./entrypoint.sh:/home/entrypoint.sh ports: - \"22102:22102/udp\" # 使用443 则改为 '443:443/tcp' - '444:444/tcp' depends_on: - mongodb stdin_open: true tty: true 创建文件 /opt/grasscutter/entrypoint.sh修改项： 123wget https://raw.githubusercontent.com/akbaryahya/DockerGC/d377538bae92a1826e3a50c647023e80dab37d62/gc/entrypoint.shsed -i \"/# Config ip/a\\ json -q -I -f config.json -e \\\"this.DispatchServer.Port=444\\\"\" entrypoint.sh 获取 resources 数据 方式1将 grasscutter.command 中的 # -f 'yes' 取消注释，运行后会按脚本内方式拉取。 方式2使用 git clone https://e.coding.net/iaoongin/grasscutters/GenshinData.git 拉取，将文件放到 ./resources 下面 启动服务1docker-compose up -d 客户端教程见 原神私服 - 客户端连接教程 参考项目Grasscutter 官方项目：https://github.com/Grasscutters/GrasscutterGenshinData 数据包: https://github.com/Dimbreath/GenshinDataDockerGC 容器化项目：https://github.com/akbaryahya/DockerGCGrasscutterCommandGenerator 指令生成器： https://github.com/jie65535/GrasscutterCommandGeneratorGrassClipper-X 原神代理启动器：https://github.com/Grasscutters/GrassClipper-X","link":"/2022/05/08/原神私服搭建/"},{"title":"数据库事务---特性、隔离级别、传播行为","text":"数据库事务特性原子性、一致性、隔离性、持久性 原子性一个事务表示 一组操作不可分割，要么同时成功，要么同时失败。如果中间发生错误，进行回滚，回到未执行之前的状态。 一致性事务开启前后，数据约束保证一致，业务逻辑保证一致。数据约束一致，比如保证外键约束，唯一约束等不被破坏。业务逻辑一致，比如存取款，保证金额总和一致。 隔离性多个事务之间独立，根据隔离级别，保证事务中的读写执行中，数据的一致性。比如A事物的读，发生在B事物写之后，A是读B写之前的数据，还是之后的数据。 持久性事务处理结束后，保证对数据的修改是永久的。 数据库隔离级别读未提交、读已提交、重复读、序列化 读未提交A 事务可以读到 B事务中，未提交的修改的数据。 读已提交A 事务可以读到 B事务提交后的数据，即A事务 在 B 事务 提交前后，进行读取，可能会出现不一样的数据。 重复读A事务 在 B 事务 提交前后，进行读取，读取的数据是一样的，即不受 B 事务的影响，不过这里局限于 Update 操作；Insert 操作的数据还是会读取到。MySQL 默认是此级别。 序列化A事务 和B事务 串行执行，不会出现以上情况，但此时性能较差。 Spring的七种事物传播行为 类型 说明 PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。 PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。 PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。 PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。 PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。 PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 参考理解事务的4种隔离级别: https://blog.csdn.net/qq_33290787/article/details/51924963 数据库事务ACID特性: https://blog.csdn.net/u012440687/article/details/52116108 Spring事务传播行为详解: https://segmentfault.com/a/1190000013341344 关于PROPAGATION_NESTED的理解: https://blog.csdn.net/yanxin1213/article/details/100582643","link":"/2022/02/12/数据库事务/"},{"title":"【黑神话】如果你开头直接秒了杨戬会怎么样？文中有资源","text":"前言 自8月20日全球上线以来，国产3A大作《黑神话：悟空》凭借其独特魅力迅速吸引全球玩家关注。在Steam平台上三天内的销量已突破840万份，好评率超过97%，平均游戏时间达到9.7小时。该游戏的总收入超过了4亿美元，约合人民币28.55亿元，创造了国产单机游戏新的记录，展现了国产游戏的强大潜力。 诚然，对于部分玩家而言，战斗的挑战性无疑是游戏的一大魅力所在。面对强大的BOSS，历经数小时的鏖战，经历无数次挫败与重生，这种不屈不挠的精神探索与突破自我的过程，正是游戏乐趣的深刻体现。当然不免有些玩家感觉战斗难，一个boss凹几个小时，死无数次。 如果说开始直接秒了杨戬，会怎么样？ 效果 教程下载修改器，直接选择要开启的神通. 然后进入游戏，开始一展拳脚。 资源 https://www.alipan.com/s/ChuFTZf7nN2 提取码 9vv1 https://pan.quark.cn/s/06fe7bbf65dc 提取码 qV53 获取更多资源","link":"/2024/08/24/黑神话/"},{"title":"IDEA打印彩色日志","text":"完成以下步骤即可,非必须完成所有步骤修改logback.xml123456789&lt;!-- logback.xml --&gt;&lt;!-- 彩色日志 --&gt;&lt;!-- 彩色日志依赖的渲染类 --&gt;&lt;conversionRule conversionWord=\"clr\" converterClass=\"org.springframework.boot.logging.logback.ColorConverter\" /&gt;&lt;conversionRule conversionWord=\"wex\" converterClass=\"org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter\" /&gt;&lt;conversionRule conversionWord=\"wEx\" converterClass=\"org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter\" /&gt;&lt;!-- 彩色日志格式 --&gt;&lt;property name=\"FILE_LOG_PATTERN\" value=\"${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}\" /&gt; 打开设置 File–Settings–Maven–Runner在 VM option 添加 1-Dspring.output.ansi.enabled=ALWAYS 打开设置 Edit-Cofiguration在 VM option 添加 1-Dspring.output.ansi.enabled=ALWAYS 效果图","link":"/2019/08/20/IDEA打印彩色日志/"},{"title":"SVN错误：XXX is scheduled for addition, but is missing","text":"解决方式告诉SVN把这个文件退回到之前的状态 “unversioned”，也就是不对这个文件做任何修改，执行完提交即可。 xxx 必须是全路径 1svn revert xxx --depth infinity 如 1svn revert H:\\abc\\config\\feign --depth infinity 场景发生在 copy to branch or tag时 原因使用svn标记了将要提交的文件，此时被你删除了，再进行提交的时候，就会找不到。 拓展svn revert 顾名思义是对修改过的东西进行回滚。如对已修改未提交的文件回滚； 深度（depth） 1234--depth empty：只包含目录自身，不包含目录下的任何文件和子目录。--depth files： 包含目录和目录下的文件，不包含子目录。--depth immediates： 包含目录和目录下的文件及子目录。但不对子目录递归。--depth infinity： 这是默认的，包含整个目录树。 svn status 查看文件状态。 本文参考SVN错误：but is missing","link":"/2019/08/19/SVN错误：XXX-is-scheduled-for-addition-but-is-missing/"},{"title":"Spring Cloud Gateway 的使用","text":"框架说明用于统一服务的出入口。 注意由于该项目使用的是Spring WebFlux，区别与Spring WebMvc。 带来的优势 做统一权限（目前） 统一日志 … 词汇路由 Route：一个组合，包含下面两个部分。 断言 Predicate：相当于转发条件。 过滤器 Filter：相当于转发规则。 有关类org.springframework.cloud.gateway.route.RouteDefinition 属性 类型 说明 id String 路由id，唯一标识。 predicates List 断言集合。 filters List 过滤集合。 uri URI 目标地址。支持http和lb。 metadata Map&lt;String, Object&gt; 元数据。 order int 顺序。 org.springframework.cloud.gateway.handler.predicate.PredicateDefinition 属性 类型 说明 name String RoutePredicateFactory名称。如：Path args Map&lt;String, String&gt; 参数。不同的RoutePredicateFactory，有不一样的参数。 org.springframework.cloud.gateway.filter.FilterDefinition 属性 类型 说明 name String GatewayFilterFactory名称。如：RewritePath，StripPrefix。 args Map&lt;String, String&gt; 参数。不同的GatewayFilterFactory，有不一样的参数。 使用动态路由说明​ 通过实现 org.springframework.cloud.gateway.route.RouteDefinitionRepository 接口，实现路由获取方式。 ​ 来自org.springframework.cloud.gateway.route.CachingRouteDefinitionLocator#fetch 的调用。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.ystmob.mg.api.config.gatewayroute;import cn.hutool.json.JSONUtil;import com.ystmob.mg.api.service.GatewayRouteService;import lombok.extern.slf4j.Slf4j;import org.springframework.cloud.gateway.route.RouteDefinition;import org.springframework.cloud.gateway.route.RouteDefinitionRepository;import org.springframework.stereotype.Component;import reactor.core.publisher.Flux;import reactor.core.publisher.Mono;import javax.annotation.Resource;import java.util.stream.Collectors;@Slf4j@Componentpublic class DynamicRouteDefinitionRepository implements RouteDefinitionRepository { @Resource private GatewayRouteService gatewayRouteService; @Override public Flux&lt;RouteDefinition&gt; getRouteDefinitions() { return gatewayRouteService.listStatusOn() .flatMapIterable(gatewayRoutes -&gt; gatewayRoutes.stream().map(gr -&gt; { String jsonString = JSONUtil.toJsonStr(gr); RouteDefinition routeDefinition = JSONUtil.toBean(jsonString, RouteDefinition.class); // id 对 routeId routeDefinition.setId(gr.getRouteId()); return routeDefinition; }).collect(Collectors.toList())); } @Override public Mono&lt;Void&gt; save(Mono&lt;RouteDefinition&gt; route) { return Mono.empty(); } @Override public Mono&lt;Void&gt; delete(Mono&lt;String&gt; routeId) { return Mono.empty(); }} 路由刷新通过发布事件，通知监听器刷新。 123456@ResourceApplicationEventPublisher publisher;... publisher.publishEvent(new RefreshRoutesEvent(this));... 监听器 org.springframework.cloud.gateway.route.CachingRouteDefinitionLocator#onApplicationEvent org.springframework.cloud.gateway.route.CachingRouteLocator#onApplicationEvent 静态路由通过配置yml文件，即提前声明的形式。 比如 123456789101112131415161718spring: application: name: stock-gateway cloud: gateway: routes: - id: stock-finance uri: lb://stock-finance predicates: - Path=/stock-finance/** filters: - RewritePath=/stock-finance, / - id: stock-ii uri: http://localhost:8510 predicates: - Path=/stock-ii/** filters: - RewritePath=/stock-ii, /","link":"/2020/06/09/Spring Cloud Gateway 的使用/"},{"title":"Welcome","text":"","link":"/2019/08/14/Welcome/"},{"title":"git push 本地项目到远程仓库","text":"1.进入项目目录1cd H:\\blog 2.初始化仓库1git init 3.添加所有文件到仓库1git add -A 4.提交1git commit -m &quot;init&quot; 5.建立好远程仓库1https://github.com/iaoongin/iaoongin.github.io.git 6.配置远程仓库http方式此方式需要输入密码12git remote add origin https://github.com/iaoongin/iaoongin.github.io.git// origin 是远程仓库的别名，用于代替git仓库地址 ssh方式此方式需要生成秘钥1git remote add origin git@github.com:iaoongin/iaoongin.github.io.git 1ssh-keygen -t rsa -C &quot;这里换上你的邮箱&quot; 生成秘钥,如下图 配置远程仓库key 7.开始推送12git push origin master:source// git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 分支说明12345// 本地默认初始为master分支// git branch -a 查看所有本地分支// git branch 查看当前分支// git branch abc 创建分支abc// git checkout abc 切换abc分支","link":"/2019/08/16/git-push-本地项目到远程仓库/"},{"title":"logstash input-jdbc 分页性能优化问题","text":"原因logstash 自带分页查询,竟然是查处所有数据再计数的。 1SELECT count(*) AS `count` FROM (SELECT * FROM ip_bundle_data_20190813) AS `t1` LIMIT 1 解决办法：修改源码 文件位置 1logstash-7.2.0\\vendor\\bundle\\jruby\\2.5.0\\gems\\logstash-input-jdbc-4.3.13\\lib\\logstash\\plugin_mixins\\jdbc\\jdbc.rb 添加参数 123456// line:100 =&gt; config# 开启子查询分页 @boole 2018-03-30config :subquery_paging_enabled, :validate =&gt; :boolean, :default =&gt; false# 总数sql，结果集列名为sum。for example `select count(*) as sum from goods` @boole 2018-03-30config :sum_statement, :validate =&gt; :string 修改方法 123456789101112131415161718192021222324252627282930// line:254 =&gt; perform_queryprivate def perform_query(query) #subquery paging @boole 2018-03-30 if @subquery_paging_enabled @logger.info(&quot;################### subquery paging optimization ################&quot;) data_sum = @database[@sum_statement].get(:sum) @logger.info(&quot;data_sum=#{data_sum}&quot;) data_offset = 0 while data_offset &lt; data_sum do @logger.info(&quot;data_offset=#{data_offset}&quot;) sub_page_query = @database[@statement, symbolized_params({&quot;data_offset&quot; =&gt; data_offset, &quot;jdbc_page_size&quot; =&gt; @jdbc_page_size})] sub_page_query.each do |row| yield row end data_offset += @jdbc_page_size end elsif @jdbc_paging_enabled query.each_page(@jdbc_page_size) do |paged_dataset| paged_dataset.each do |row| yield row end end else query.each do |row| yield row end end end 配置logstash.conf sql中使用:data_offset和:jdbc_page_size进行分页 12345statement =&gt; &quot;SELECT * FROM ip_bundle_data_20190813 limit :data_offset,:jdbc_page_size&quot;subquery_paging_enabled =&gt; &quot;true&quot;sum_statement =&gt; &quot;select count(*) as `count` from ip_bundle_data_20190813&quot;","link":"/2019/08/14/logstash 分页优化/"},{"title":"logstash input-jdbc 分页性能优化问题","text":"原因logstash 自带分页查询,竟然是查处所有数据再计数的。 1SELECT count(*) AS `count` FROM (SELECT * FROM ip_bundle_data_20190813) AS `t1` LIMIT 1 解决办法：修改源码文件位置1logstash-7.2.0\\vendor\\bundle\\jruby\\2.5.0\\gems\\logstash-input-jdbc-4.3.13\\lib\\logstash\\plugin_mixins\\jdbc\\jdbc.rb 添加参数123456// line:100 =&gt; config# 开启子查询分页 @boole 2018-03-30config :subquery_paging_enabled, :validate =&gt; :boolean, :default =&gt; false# 总数sql，结果集列名为sum。for example `select count(*) as sum from goods` @boole 2018-03-30config :sum_statement, :validate =&gt; :string 修改方法123456789101112131415161718192021222324252627282930// line:254 =&gt; perform_queryprivate def perform_query(query) #subquery paging @boole 2018-03-30 if @subquery_paging_enabled @logger.info(&quot;################### subquery paging optimization ################&quot;) data_sum = @database[@sum_statement].get(:sum) @logger.info(&quot;data_sum=#{data_sum}&quot;) data_offset = 0 while data_offset &lt; data_sum do @logger.info(&quot;data_offset=#{data_offset}&quot;) sub_page_query = @database[@statement, symbolized_params({&quot;data_offset&quot; =&gt; data_offset, &quot;jdbc_page_size&quot; =&gt; @jdbc_page_size})] sub_page_query.each do |row| yield row end data_offset += @jdbc_page_size end elsif @jdbc_paging_enabled query.each_page(@jdbc_page_size) do |paged_dataset| paged_dataset.each do |row| yield row end end else query.each do |row| yield row end end end 配置logstash.confsql中使用:data_offset和:jdbc_page_size进行分页 12345statement =&gt; &quot;SELECT * FROM ip_bundle_data_20190813 limit :data_offset,:jdbc_page_size&quot;subquery_paging_enabled =&gt; &quot;true&quot;sum_statement =&gt; &quot;select count(*) as `count` from ip_bundle_data_20190813&quot;","link":"/2019/08/14/logstash-分页优化/"},{"title":"mysql导入大文件失败解决方法","text":"解决方式修改/etc/my.conf,在以指定区域新增以下行 1234567891011[mysqld]#### 避免导入失败max_allowed_packet = 200M[mysqlhotcopy]interactive-timeout=28800000wait_timeout=28800000#### 避免导入失败 场景导入的sql文件较大时，或者网络状况不好。 原因mysql 默认配置超时时间及支持文件大小限制太小","link":"/2019/08/20/mysql导入大文件失败解决方法/"},{"title":"spring中将配置文件的属性注入到静态属性里","text":"场景如在工具类中，不想将该工具类被spring管理，通过引用其他类的的静态属性获取值。 步骤application.properties123456#局域网地址file.lanServer=\\\\\\\\DESKTOP-3FE3ORR\\\\app\\\\#app下载地址file.remoteServer=http://127.0.0.1:8080/app/file.fileUploadDir=H:/vadxfile.relatePath=/vadx/app 新建类, 如文件路径配置123456789101112131415161718192021222324252627282930@Component@Getter@Setterpublic class FileProp { public static String remoteServer; public static String lanServer; public static String fileUploadDir; public static String relatePath; @Value(\"${file.remoteServer}\") public void setRemoteServer(String remoteServer) { FileProp.remoteServer = remoteServer; } @Value(\"${file.lanServer}\") public void setLanServer(String lanServer) { FileProp.lanServer = lanServer; } @Value(\"${file.fileUploadDir}\") public void setFileUploadDir(String fileUploadDir) { FileProp.fileUploadDir = fileUploadDir; } @Value(\"${file.relatePath}\") public void setRelatePath(String relatePath) { FileProp.relatePath = relatePath; }} 使用，在工具类中使用123456@Slf4jpublic class UploadFileUtil { //项目前缀路径 public static String destFile = FileProp.fileUploadDir;}","link":"/2019/11/02/spring中将配置文件的属性注入到静态属性里/"},{"title":"windows-运行关闭jar包cmd脚本","text":"项目结构123456|--web |-- appname.txt // 存放jar包名字 |-- xxx.jar // jar包 |-- run.bat // 前台启动脚本 |-- run-demo.bat // 后台启动脚本 |-- stop.bat // 停止脚本 前台启动脚本12345chcp 65001for /f \"tokens=1\" %%j in ('findstr .* appname.txt') do ( title %%j java -jar -Dfile.encoding=UTF-8 -Dlogging.config=config/logback.xml -Dspring.profiles.active=pro -Dmybatis-plus.mapper-locations=file:config/mapper/*.xml \"%%j\" -Xms50m -Xmx1024m) 后台启动脚本12345chcp 65001for /f \"tokens=1\" %%j in ('findstr .* appname.txt') do ( title %%j start javaw -jar -Dlogging.config=config/logback.xml -Dspring.profiles.active=pro -Dmybatis-plus.mapper-locations=file:config/mapper/*.xml \"%%j\" -Xms256m -Xmx1g -Xss256k) 停止脚本注：&quot;C:\\Program Files\\Java\\jdk1.8.0_131\\bin\\jps&quot; 为jdk工具包 12345678910111213@echo off:: 找到jar的pid进程，并杀死for /f \"tokens=1\" %%j in ('findstr .* appname.txt') do ( for /f \"tokens=1\" %%i in ('\"C:\\Program Files\\Java\\jdk1.8.0_131\\bin\\jps\" -l ^| findstr %%j') do ( set n=%%i ))taskkill /f /pid %n%set n=exit 参考win bat脚本 后台运行jar包 获取当前用户所有java进程及jps命令的实现","link":"/2019/08/26/windows-运行关闭jar包cmd脚本/"},{"title":"PowerMock使用","text":"简介​ 可用于本地单元测试的框架。可模拟公有，私有方法返回数据；也可模拟静态属性数据，实例属性数据；模拟Spring Bean 实例及注入等。 与Mockito的区别PowerMock较Mockito强大一点，可以模拟私有方法，静态方法，final 类。 maven依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.powermock&lt;/groupId&gt; &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.powermock&lt;/groupId&gt; &lt;artifactId&gt;powermock-api-mockito2&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 说明@Mock 和 @Spy 区别@Mock：模拟出来的对象，其所有方法是空的，调用都返回空，真实的方法不会执行。 @Spy：模拟出来的对象，其所有方法都是真实的，调用都按真实方法去调用，因此很可能依赖真实的环境。除非mock 对应的方法，才会覆盖。 doReturn()…when() 和when()…thenReturn() 的区别mock 出来的对象： 没有区别。 spy出来的对象：doReturn()…when() 和when()…thenReturn() 是有区别的 使用模拟公有方法 设置Runner环境为PowerMockRunner 123456// FoodMenuServiceTest.class ...@RunWith(PowerMockRunner.class)public class FoodMenuServiceTest{ // ...} 定义Mock属性和需要注入的属性。 1234567891011// FoodMenuServiceTest.class ...// 需要注入（Mock的属性）的属性,此处需要new具体类 @InjectMocks private FoodMenuService foodMenuService = new FoodMenuServiceImpl();// Mock 的属性 @Mock private MaterialService materialService;// ... 构造数据，模拟方法，运行 12345678910111213141516171819202122 // FoodMenuServiceTest.class ...@Test public void mockPublicMethod() { // 数据 Material fish = Material.builder().name(\"鱼\").build(); Material crayFish = Material.builder().name(\"小龙虾\").build(); ArrayList&lt;Material&gt; materials = CollUtil.newArrayList(fish, crayFish); // 模拟方法 list PowerMockito.when(materialService.list()).thenReturn(materials); // 调用 List&lt;Food&gt; list = foodMenuService.list(); // 打印结果 // [Food(name=红烧鱼), Food(name=水煮鱼), Food(name=麻辣小龙虾), Food(name=清蒸小龙虾)] System.out.println(list); }// ... 模拟私有方法 设置runner环境为PowerMockRunner,并设置PrepareForTest为需要测试的类PrepareForTest 123456// MockPrivateMethodTest.class@RunWith(PowerMockRunner.class)@PrepareForTest(MaterialServiceImpl.class)public class MockPrivateMethodTest { // ...} 定义需要Spy的属性 123// MockPrivateMethodTest.class @Spy private MaterialService materialService = new MaterialServiceImpl(); 构造数据，模拟方法，运行 123456789101112131415161718192021// MockPrivateMethodTest.class@Test public void mockPrivateMethod() throws Exception { // 数据 Material fish = Material.builder().name(\"鱼\").build(); Material crayFish = Material.builder().name(\"小龙虾\").build(); ArrayList&lt;Material&gt; materials = CollUtil.newArrayList(fish, crayFish); // 模拟方法 // 区别于 PowerMockito.when(materialService, \"pri\").thenReturn(materials); PowerMockito.doReturn(materials).when(materialService, \"pri\"); // 执行 List&lt;Material&gt; list = materialService.listForPri(); // 打印 // [Material(name=鱼), Material(name=小龙虾)] System.out.println(list); } 同时模拟共有和私有方法，并注入 设置Runner和PrepareForTest 123456// MockPublicAndPrivateMethodTest.class@RunWith(PowerMockRunner.class)@PrepareForTest(MaterialServiceImpl.class)public class MockPublicAndPrivateMethodTest { // ...} 定义属性 123456 @InjectMocks private FoodMenuService foodMenuService = new FoodMenuServiceImpl();// 因为要调用 MaterialService.listForPubAndPri的实际方法，顾使用 @Spy，如不需可使用@Mock @Spy private MaterialService materialService = new MaterialServiceImpl(); 构造数据，模拟方法，运行 123456789101112131415161718192021222324@Test public void mockPublicAndPrivateMethod() throws Exception { // 构造数据 Material fish = Material.builder().name(\"鱼\").build(); Material crayFish = Material.builder().name(\"小龙虾\").build(); ArrayList&lt;Material&gt; materialsA = CollUtil.newArrayList(fish); ArrayList&lt;Material&gt; materialsB = CollUtil.newArrayList(crayFish); // 模拟公有方法 // 此处用方法名的形式是因为 spy出来的对象具有真实方法，以方法名的方式调用不会执行真实方法。 PowerMockito.doReturn(materialsA).when(materialService, \"list\"); // 模拟私有方法 PowerMockito.doReturn(materialsB).when(materialService, \"pri\"); // 运行 List&lt;Food&gt; list = foodMenuService.listForPubAndPri(); // 打印 // [Food(name=红烧鱼), Food(name=水煮鱼), Food(name=麻辣小龙虾), Food(name=清蒸小龙虾)] System.out.println(list); } 模拟静态方法1234567891011121314151617181920212223242526272829import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.powermock.api.mockito.PowerMockito;import org.powermock.core.classloader.annotations.PrepareForTest;import org.powermock.modules.junit4.PowerMockRunner;@RunWith(PowerMockRunner.class)@PrepareForTest(StaticMethodAndField.class)public class StaticMethodAndFieldTest { // 期望数据 public static final String expect = \"127.0.0.1\"; @Test public void mockStaticMethod() { // 模拟方法 PowerMockito.mockStatic(StaticMethodAndField.class); PowerMockito.when(StaticMethodAndField.getIp()).thenReturn(expect); // 调用 String ip = StaticMethodAndField.getIp(); // 断言 Assert.assertEquals(expect, ip); }} 模拟静态私有属性12345678910111213141516171819202122232425262728293031323334353637383940@RunWith(PowerMockRunner.class)@PrepareForTest(StaticMethodAndField.class)public class StaticMethodAndFieldTest { // 期望数据 public static final String expect = \"127.0.0.1\"; /** * 参考 https://qa.1r1g.com/sf/ask/1621376431/ * @throws NoSuchFieldException * @throws IllegalAccessException */ @Test public void mockFinalField() throws NoSuchFieldException, IllegalAccessException { // 模拟属性 // 获取字段 Field field = Whitebox.getField(StaticMethodAndField.class, \"IP\"); // 设置成public field.setAccessible(true); // 获取 修饰器 Field modifiersField = Field.class.getDeclaredField(\"modifiers\"); // 设置为可使用的 modifiersField.setAccessible(true); // 消除 FINAL 修饰器 modifiersField.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL); // 设置新值 field.set(null, expect); // 断言 Assert.assertEquals(expect, StaticMethodAndField.IP); }} 模拟枚举类1234567891011121314151617181920212223242526272829303132import org.junit.Test;import org.junit.runner.RunWith;import org.powermock.api.mockito.PowerMockito;import org.powermock.core.classloader.annotations.PrepareForTest;import org.powermock.modules.junit4.PowerMockRunner;import org.powermock.reflect.Whitebox;import static org.junit.Assert.*;@RunWith(PowerMockRunner.class)@PrepareForTest(Colors.class)public class ColorsTest { @Test public void mockEnums() { // 期望的数据 String expect = \"模拟的蓝色\"; // 模拟的实例 Colors instance = PowerMockito.mock(Colors.class); // 替换实例 Whitebox.setInternalState(Colors.class, \"BLUE\", instance); // 模拟方法 PowerMockito.when(instance.getName() ).thenReturn(expect); // 断言 assertEquals(expect, Colors.BLUE.getName()); }} 项目源码1https://github.com/iaoongin/summary-project/sp-powermock","link":"/2020/10/20/PowerMock使用/"}],"tags":[{"name":"git","slug":"git","link":"/tags/git/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"containerd","slug":"containerd","link":"/tags/containerd/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"yarn","slug":"yarn","link":"/tags/yarn/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"docker-compose","slug":"docker-compose","link":"/tags/docker-compose/"},{"name":"Grasscutter","slug":"Grasscutter","link":"/tags/Grasscutter/"},{"name":"原神","slug":"原神","link":"/tags/原神/"},{"name":"私服","slug":"私服","link":"/tags/私服/"},{"name":"客户端","slug":"客户端","link":"/tags/客户端/"},{"name":"抽卡模拟器","slug":"抽卡模拟器","link":"/tags/抽卡模拟器/"},{"name":"满命","slug":"满命","link":"/tags/满命/"},{"name":"除草机","slug":"除草机","link":"/tags/除草机/"},{"name":"代理","slug":"代理","link":"/tags/代理/"},{"name":"3.2","slug":"3-2","link":"/tags/3-2/"},{"name":"补丁","slug":"补丁","link":"/tags/补丁/"},{"name":"最新","slug":"最新","link":"/tags/最新/"},{"name":"服务器","slug":"服务器","link":"/tags/服务器/"},{"name":"服务端","slug":"服务端","link":"/tags/服务端/"},{"name":"数据库","slug":"数据库","link":"/tags/数据库/"},{"name":"db","slug":"db","link":"/tags/db/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"隔离级别","slug":"隔离级别","link":"/tags/隔离级别/"},{"name":"传播行为","slug":"传播行为","link":"/tags/传播行为/"},{"name":"事务特性","slug":"事务特性","link":"/tags/事务特性/"},{"name":"黑神话","slug":"黑神话","link":"/tags/黑神话/"},{"name":"悟空","slug":"悟空","link":"/tags/悟空/"},{"name":"修改器","slug":"修改器","link":"/tags/修改器/"},{"name":"idea","slug":"idea","link":"/tags/idea/"},{"name":"log","slug":"log","link":"/tags/log/"},{"name":"svn","slug":"svn","link":"/tags/svn/"},{"name":"gateway","slug":"gateway","link":"/tags/gateway/"},{"name":"spring cloud","slug":"spring-cloud","link":"/tags/spring-cloud/"},{"name":"elk","slug":"elk","link":"/tags/elk/"},{"name":"logstash","slug":"logstash","link":"/tags/logstash/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"jar","slug":"jar","link":"/tags/jar/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"cmd","slug":"cmd","link":"/tags/cmd/"},{"name":"mock","slug":"mock","link":"/tags/mock/"}],"categories":[{"name":"code","slug":"code","link":"/categories/code/"},{"name":"game","slug":"game","link":"/categories/game/"}]}